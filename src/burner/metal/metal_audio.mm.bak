#import <Cocoa/Cocoa.h>
#import <AudioToolbox/AudioToolbox.h>
#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>
#include "burnint.h"
#include <CoreAudio/CoreAudio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "metal_declarations.h"
#include "metal_audio.h"
#include "metal_bridge.h"

// Constants for audio configuration
#define AUDIO_SAMPLE_RATE 48000
#define AUDIO_CHANNELS 2
#define AUDIO_BUFFER_COUNT 3
#define AUDIO_BUFFER_FRAMES 2048

// Audio state structure
typedef struct {
    AudioQueueRef queue;
    AudioQueueBufferRef buffers[AUDIO_BUFFER_COUNT];
    BOOL isRunning;
    float volume;
    int sampleRate;
    int channels;
    int bytesPerFrame;
    int bufferSize;
    AudioStreamBasicDescription format;
} MetalAudioState;

// Global audio state
static MetalAudioState gAudioState;

// Audio engine
static AVAudioEngine* audioEngine = nil;
static AVAudioSourceNode* sourceNode = nil;
static BOOL audioInitialized = NO;
static int audioSampleRate = 44100;
static int audioChannels = 2;

// Audio buffer
static short* audioBuffer = NULL;
static int audioBufferSize = 0;
static int audioBufferPos = 0;
static dispatch_semaphore_t audioSemaphore;

// Audio callback function prototype
typedef void (*AudioCallbackFunc)(short* buffer, int samples);

// Audio state
static AudioComponentInstance audioUnit = NULL;
static AudioBufferList* audioBufferList = NULL;
static short* audioRingBuffer = NULL;
static int ringBufferSize = 0;
static int readPos = 0;
static int writePos = 0;
static float volume = 1.0f;
static bool audioPaused = false;
static AudioCallbackFunc audioCallback = NULL;
static int audioFrameSize = 0;

// Mutex for thread safety
static pthread_mutex_t audioMutex = PTHREAD_MUTEX_INITIALIZER;

// Ring buffer management
static inline int RingBufferFree() {
    int free = readPos - writePos - 1;
    if (free < 0) {
        free += ringBufferSize;
    }
    return free;
}

static inline int RingBufferAvailable() {
    int available = writePos - readPos;
    if (available < 0) {
        available += ringBufferSize;
    }
    return available;
}

static void RingBufferWrite(const short* data, int samples) {
    pthread_mutex_lock(&audioMutex);
    
    int samplesWritten = 0;
    int samplesToWrite = samples;
    
    // Check if we have enough space
    if (samplesToWrite > RingBufferFree() / 2) {
        // Not enough space, only write what we can
        samplesToWrite = RingBufferFree() / 2;
    }
    
    while (samplesWritten < samplesToWrite) {
        int toWrite = samplesToWrite - samplesWritten;
        int contiguous = ringBufferSize - writePos;
        if (contiguous > toWrite) {
            contiguous = toWrite;
        }
        
        // Copy data to ring buffer
        memcpy(&audioRingBuffer[writePos * 2], &data[samplesWritten * 2], contiguous * 2 * sizeof(short));
        
        writePos = (writePos + contiguous) % ringBufferSize;
        samplesWritten += contiguous;
    }
    
    pthread_mutex_unlock(&audioMutex);
}

static int RingBufferRead(short* data, int samples) {
    pthread_mutex_lock(&audioMutex);
    
    int samplesRead = 0;
    int samplesToRead = samples;
    
    // Check how many samples are available
    int available = RingBufferAvailable();
    if (samplesToRead > available) {
        samplesToRead = available;
    }
    
    while (samplesRead < samplesToRead) {
        int toRead = samplesToRead - samplesRead;
        int contiguous = ringBufferSize - readPos;
        if (contiguous > toRead) {
            contiguous = toRead;
        }
        
        // Copy data from ring buffer
        memcpy(&data[samplesRead * 2], &audioRingBuffer[readPos * 2], contiguous * 2 * sizeof(short));
        
        readPos = (readPos + contiguous) % ringBufferSize;
        samplesRead += contiguous;
    }
    
    // If we couldn't read enough samples, fill the rest with silence
    if (samplesRead < samples) {
        memset(&data[samplesRead * 2], 0, (samples - samplesRead) * 2 * sizeof(short));
    }
    
    pthread_mutex_unlock(&audioMutex);
    return samplesRead;
}

// Audio callback function
static OSStatus AudioOutputCallback(void* inRefCon,
                                    AudioUnitRenderActionFlags* ioActionFlags,
                                    const AudioTimeStamp* inTimeStamp,
                                    UInt32 inBusNumber,
                                    UInt32 inNumberFrames,
                                    AudioBufferList* ioData) {
    if (audioPaused) {
        // Fill with silence if paused
        for (int i = 0; i < ioData->mNumberBuffers; i++) {
            memset(ioData->mBuffers[i].mData, 0, ioData->mBuffers[i].mDataByteSize);
        }
        return noErr;
    }
    
    // Read from ring buffer
    short* outBuffer = (short*)ioData->mBuffers[0].mData;
    int framesToRead = inNumberFrames;
    
    // Apply volume
    int samplesRead = RingBufferRead(outBuffer, framesToRead);
    
    // Apply volume
    if (volume != 1.0f) {
        for (int i = 0; i < framesToRead * 2; i++) {
            float sample = outBuffer[i] * volume;
            if (sample > 32767.0f) sample = 32767.0f;
            if (sample < -32768.0f) sample = -32768.0f;
            outBuffer[i] = (short)sample;
        }
    }
    
    // If we didn't have enough samples, call the callback to generate more
    if (samplesRead < framesToRead && audioCallback) {
        short tempBuffer[framesToRead * 2];
        audioCallback(tempBuffer, framesToRead);
        RingBufferWrite(tempBuffer, framesToRead);
    }
    
    return noErr;
}

// Initialize the audio system
int Metal_InitAudioSystem(int inSampleRate) {
    printf("Metal_InitAudioSystem(%d) called\n", inSampleRate);
    
    // Already initialized?
    if (audioInitialized) {
        printf("Audio already initialized, shutting down first\n");
        Metal_ShutdownAudio();
    }
    
    // Store sample rate
    sampleRate = inSampleRate > 0 ? inSampleRate : 44100;
    
    // Create the audio component description
    AudioComponentDescription desc;
    desc.componentType = kAudioUnitType_Output;
    desc.componentSubType = kAudioUnitSubType_DefaultOutput;
    desc.componentManufacturer = kAudioUnitManufacturer_Apple;
    desc.componentFlags = 0;
    desc.componentFlagsMask = 0;
    
    // Find the default output audio unit
    AudioComponent outputComponent = AudioComponentFindNext(NULL, &desc);
    if (outputComponent == NULL) {
        printf("Failed to find default audio output component\n");
        return 1;
    }
    
    // Create the audio unit
    OSStatus status = AudioComponentInstanceNew(outputComponent, &audioUnit);
    if (status != noErr) {
        printf("Failed to create audio unit: %d\n", (int)status);
        return 1;
    }
    
    // Set up audio format
    AudioStreamBasicDescription audioFormat;
    memset(&audioFormat, 0, sizeof(audioFormat));
    audioFormat.mSampleRate = sampleRate;
    audioFormat.mFormatID = kAudioFormatLinearPCM;
    audioFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked;
    audioFormat.mFramesPerPacket = 1;
    audioFormat.mChannelsPerFrame = 2; // Stereo
    audioFormat.mBitsPerChannel = 16;
    audioFormat.mBytesPerPacket = 4;
    audioFormat.mBytesPerFrame = 4;
    
    status = AudioUnitSetProperty(audioUnit,
                                 kAudioUnitProperty_StreamFormat,
                                 kAudioUnitScope_Input,
                                 0,
                                 &audioFormat,
                                 sizeof(audioFormat));
    
    if (status != noErr) {
        printf("Failed to set audio unit format: %d\n", (int)status);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
        return 1;
    }
    
    // Set up the audio callback
    AURenderCallbackStruct callbackStruct;
    callbackStruct.inputProc = AudioOutputCallback;
    callbackStruct.inputProcRefCon = NULL;
    
    status = AudioUnitSetProperty(audioUnit,
                                 kAudioUnitProperty_SetRenderCallback,
                                 kAudioUnitScope_Input,
                                 0,
                                 &callbackStruct,
                                 sizeof(callbackStruct));
    
    if (status != noErr) {
        printf("Failed to set audio callback: %d\n", (int)status);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
        return 1;
    }
    
    // Initialize the audio unit
    status = AudioUnitInitialize(audioUnit);
    if (status != noErr) {
        printf("Failed to initialize audio unit: %d\n", (int)status);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
        return 1;
    }
    
    // Calculate a good buffer size (2 seconds of audio)
    ringBufferSize = sampleRate * 2;
    audioRingBuffer = (short*)malloc(ringBufferSize * 2 * sizeof(short)); // Stereo, so * 2
    
    if (!audioRingBuffer) {
        printf("Failed to allocate audio ring buffer\n");
        AudioUnitUninitialize(audioUnit);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
        return 1;
    }
    
    // Clear the ring buffer
    memset(audioRingBuffer, 0, ringBufferSize * 2 * sizeof(short));
    readPos = 0;
    writePos = 0;
    
    // Init audio frame size (for one frame of emulation)
    audioFrameSize = sampleRate / 60; // Assuming 60 FPS
    
    // Set initial volume
    volume = 1.0f;
    
    // Start the audio unit
    status = AudioOutputUnitStart(audioUnit);
    if (status != noErr) {
        printf("Failed to start audio unit: %d\n", (int)status);
        free(audioRingBuffer);
        audioRingBuffer = NULL;
        AudioUnitUninitialize(audioUnit);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
        return 1;
    }
    
    // Mark as initialized
    audioInitialized = true;
    audioPaused = false;
    
    printf("Audio initialized: %dHz, buffer size: %d samples\n", 
           sampleRate, ringBufferSize);
    
    return 0;
}

// Shutdown the audio system
int Metal_ShutdownAudio_UNUSED() {
    if (!audioInitialized) {
        return 0;
    }
    
    printf("Metal_ShutdownAudio called\n");
    
    // Stop the audio unit
    if (audioUnit) {
        AudioOutputUnitStop(audioUnit);
        AudioUnitUninitialize(audioUnit);
        AudioComponentInstanceDispose(audioUnit);
        audioUnit = NULL;
    }
    
    // Free the ring buffer
    if (audioRingBuffer) {
        free(audioRingBuffer);
        audioRingBuffer = NULL;
    }
    
    // Mark as not initialized
    audioInitialized = false;
    
    printf("Audio shutdown complete\n");
    
    return 0;
}

// Set the audio callback function
int Metal_SetAudioCallback(AudioCallbackFunc callback) {
    audioCallback = callback;
    return 0;
}

// Add audio samples to the buffer
int Metal_AddAudioSamples(const short* samples, int count) {
    if (!audioInitialized || !audioRingBuffer) {
        return 1;
    }
    
    RingBufferWrite(samples, count);
    
    return 0;
}

// Pause or resume audio
int Metal_PauseAudio(int pause) {
    audioPaused = pause ? true : false;
    printf("Audio %s\n", audioPaused ? "paused" : "resumed");
    return 0;
}

// Set the audio volume (0.0 to 1.0)
int Metal_SetAudioVolume(float newVolume) {
    if (newVolume < 0.0f) newVolume = 0.0f;
    if (newVolume > 1.0f) newVolume = 1.0f;
    
    volume = newVolume;
    return 0;
}

// Get the audio volume (0.0 to 1.0)
float Metal_GetAudioVolume() {
    return volume;
}

// Check if audio is initialized
bool Metal_IsAudioInitialized() {
    return audioInitialized;
}

// Get the audio frame size (samples per frame)
int Metal_GetAudioFrameSize() {
    return audioFrameSize;
}

// Generate and add audio for one frame of emulation
int Metal_ProcessAudioFrame() {
    if (!audioInitialized || !audioCallback) {
        return 1;
    }
    
    // Calculate samples for one frame
    int samples = sampleRate / 60; // Assuming 60 FPS
    
    // Check if we have enough space in the ring buffer
    if (RingBufferFree() < samples * 2) {
        // Not enough space, skip this frame
        printf("Audio buffer overflow, skipping frame\n");
        return 1;
    }
    
    // Generate audio samples
    short* tempBuffer = (short*)malloc(samples * 2 * sizeof(short));
    if (!tempBuffer) {
        return 1;
    }
    
    // Call the callback to fill the buffer
    audioCallback(tempBuffer, samples);
    
    // Add to ring buffer
    RingBufferWrite(tempBuffer, samples);
    
    // Free temp buffer
    free(tempBuffer);
    
    return 0;
}

// Reset the audio system
int Metal_ResetAudio() {
    if (!audioInitialized) {
        return 1;
    }
    
    // Clear the ring buffer
    pthread_mutex_lock(&audioMutex);
    memset(audioRingBuffer, 0, ringBufferSize * 2 * sizeof(short));
    readPos = 0;
    writePos = 0;
    pthread_mutex_unlock(&audioMutex);
    
    return 0;
}

// Get buffer fill percentage (0.0 to 1.0)
float Metal_GetAudioBufferFillPercentage() {
    if (!audioInitialized) {
        return 0.0f;
    }
    
    int available = RingBufferAvailable();
    return (float)available / (float)ringBufferSize;
}

// Implementation of public interface functions
int MetalAudioInit() {
    return Metal_InitAudioSystem(44100);
}

int MetalAudioExit() {
    return Metal_ShutdownAudio();
}

int MetalAudioPlay() {
    return Metal_PauseAudio(0);
}

int MetalAudioStop() {
    return Metal_PauseAudio(1);
}

int MetalAudioSetVolume(int vol) {
    return Metal_SetAudioVolume(vol / 100.0f);
}

int MetalAudioGetSettings(InterfaceInfo* pInfo) {
    if (pInfo) {
        pInfo->nAudSampleRate = sampleRate;
        pInfo->nAudVolume = (int)(volume * 100.0f);
        pInfo->bAudOkay = audioInitialized;
    }
    return 0;
}

// Audio callback function
static void AudioQueueCallback(void* userData, AudioQueueRef queue, AudioQueueBufferRef buffer) {
    if (!gAudioState.isRunning) {
        memset(buffer->mAudioData, 0, buffer->mAudioDataBytesCapacity);
        buffer->mAudioDataByteSize = buffer->mAudioDataBytesCapacity;
        AudioQueueEnqueueBuffer(queue, buffer, 0, NULL);
        return;
    }
    
    // Get audio samples from FBNeo core
    extern void BurnSoundRender(INT16* pDest, INT32 nLen);
    
    // Calculate how many frames we need to render
    int framesToRender = buffer->mAudioDataBytesCapacity / gAudioState.bytesPerFrame;
    
    // Render audio frames
    BurnSoundRender((INT16*)buffer->mAudioData, framesToRender);
    
    // Set the actual audio data size
    buffer->mAudioDataByteSize = framesToRender * gAudioState.bytesPerFrame;
    
    // Enqueue the buffer back to the audio queue
    AudioQueueEnqueueBuffer(queue, buffer, 0, NULL);
}

// Initialize the audio system
int MetalAudio_Init(int sampleRate, int channels) {
    NSLog(@"MetalAudio_Init: Initializing audio (%d Hz, %d channels)", sampleRate, channels);
    
    // Store audio parameters
    gAudioState.sampleRate = (sampleRate > 0) ? sampleRate : AUDIO_SAMPLE_RATE;
    gAudioState.channels = (channels > 0) ? channels : AUDIO_CHANNELS;
    gAudioState.bytesPerFrame = gAudioState.channels * sizeof(INT16); // 16-bit samples
    gAudioState.bufferSize = AUDIO_BUFFER_FRAMES * gAudioState.bytesPerFrame;
    gAudioState.volume = 1.0f;
    gAudioState.isRunning = NO;
    
    // Set up audio format
    AudioStreamBasicDescription& format = gAudioState.format;
    memset(&format, 0, sizeof(format));
    format.mSampleRate = gAudioState.sampleRate;
    format.mFormatID = kAudioFormatLinearPCM;
    format.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
    format.mBitsPerChannel = 8 * sizeof(INT16);
    format.mChannelsPerFrame = gAudioState.channels;
    format.mBytesPerFrame = gAudioState.bytesPerFrame;
    format.mFramesPerPacket = 1;
    format.mBytesPerPacket = format.mBytesPerFrame * format.mFramesPerPacket;
    format.mReserved = 0;
    
    // Create the audio queue
    OSStatus status = AudioQueueNewOutput(&format, 
                                          AudioQueueCallback, 
                                          NULL, 
                                          NULL, 
                                          NULL, 
                                          0, 
                                          &gAudioState.queue);
    
    if (status != noErr) {
        NSLog(@"MetalAudio_Init: Failed to create audio queue (error %d)", (int)status);
        return 1;
    }
    
    // Create and enqueue audio buffers
    for (int i = 0; i < AUDIO_BUFFER_COUNT; i++) {
        status = AudioQueueAllocateBuffer(gAudioState.queue, 
                                          gAudioState.bufferSize, 
                                          &gAudioState.buffers[i]);
        
        if (status != noErr) {
            NSLog(@"MetalAudio_Init: Failed to allocate audio buffer %d (error %d)", 
                  i, (int)status);
            MetalAudio_Exit();
            return 1;
        }
        
        // Fill with silence
        memset(gAudioState.buffers[i]->mAudioData, 0, gAudioState.bufferSize);
        gAudioState.buffers[i]->mAudioDataByteSize = gAudioState.bufferSize;
        
        // Enqueue the buffer
        status = AudioQueueEnqueueBuffer(gAudioState.queue, 
                                         gAudioState.buffers[i], 
                                         0, 
                                         NULL);
        
        if (status != noErr) {
            NSLog(@"MetalAudio_Init: Failed to enqueue audio buffer %d (error %d)", 
                  i, (int)status);
            MetalAudio_Exit();
            return 1;
        }
    }
    
    // Set the audio queue volume
    AudioQueueSetParameter(gAudioState.queue, kAudioQueueParam_Volume, gAudioState.volume);
    
    NSLog(@"MetalAudio_Init: Audio system initialized successfully");
    return 0;
}

// Start audio playback
int MetalAudio_Start() {
    if (!gAudioState.queue) {
        NSLog(@"MetalAudio_Start: Audio system not initialized");
        return 1;
    }
    
    if (gAudioState.isRunning) {
        NSLog(@"MetalAudio_Start: Audio system already running");
        return 0;
    }
    
    // Start the audio queue
    OSStatus status = AudioQueueStart(gAudioState.queue, NULL);
    if (status != noErr) {
        NSLog(@"MetalAudio_Start: Failed to start audio queue (error %d)", (int)status);
        return 1;
    }
    
    gAudioState.isRunning = YES;
    NSLog(@"MetalAudio_Start: Audio system started");
    return 0;
}

// Stop audio playback
int MetalAudio_Stop() {
    if (!gAudioState.queue || !gAudioState.isRunning) {
        return 0;
    }
    
    // Stop the audio queue
    OSStatus status = AudioQueueStop(gAudioState.queue, true);
    if (status != noErr) {
        NSLog(@"MetalAudio_Stop: Failed to stop audio queue (error %d)", (int)status);
        return 1;
    }
    
    gAudioState.isRunning = NO;
    NSLog(@"MetalAudio_Stop: Audio system stopped");
    return 0;
}

// Clean up audio resources
int MetalAudio_Exit() {
    // Stop the audio if it's running
    MetalAudio_Stop();
    
    // Dispose of the audio queue
    if (gAudioState.queue) {
        AudioQueueDispose(gAudioState.queue, true);
        gAudioState.queue = NULL;
    }
    
    NSLog(@"MetalAudio_Exit: Audio system cleaned up");
    return 0;
}

// Set audio volume (0.0 - 1.0)
int MetalAudio_SetVolume(float volume) {
    if (!gAudioState.queue) {
        return 1;
    }
    
    // Clamp volume to valid range
    volume = (volume < 0.0f) ? 0.0f : ((volume > 1.0f) ? 1.0f : volume);
    gAudioState.volume = volume;
    
    // Set the audio queue volume
    OSStatus status = AudioQueueSetParameter(gAudioState.queue, 
                                            kAudioQueueParam_Volume, 
                                            volume);
    
    if (status != noErr) {
        NSLog(@"MetalAudio_SetVolume: Failed to set volume (error %d)", (int)status);
        return 1;
    }
    
    return 0;
}

// Pause/resume audio
int MetalAudio_Pause(BOOL pause) {
    if (pause && gAudioState.isRunning) {
        return MetalAudio_Stop();
    } else if (!pause && !gAudioState.isRunning) {
        return MetalAudio_Start();
    }
    return 0;
}

// Reset the audio system
int MetalAudio_Reset() {
    // Stop the audio
    int result = MetalAudio_Stop();
    if (result != 0) {
        return result;
    }
    
    // Re-enqueue the buffers
    for (int i = 0; i < AUDIO_BUFFER_COUNT; i++) {
        if (gAudioState.buffers[i]) {
            // Fill with silence
            memset(gAudioState.buffers[i]->mAudioData, 0, gAudioState.bufferSize);
            gAudioState.buffers[i]->mAudioDataByteSize = gAudioState.bufferSize;
            
            // Enqueue the buffer
            OSStatus status = AudioQueueEnqueueBuffer(gAudioState.queue, 
                                                     gAudioState.buffers[i], 
                                                     0, 
                                                     NULL);
            
            if (status != noErr) {
                NSLog(@"MetalAudio_Reset: Failed to enqueue audio buffer %d (error %d)", 
                      i, (int)status);
                return 1;
            }
        }
    }
    
    // Start the audio
    return MetalAudio_Start();
}

// Get current audio state
BOOL MetalAudio_IsRunning() {
    return gAudioState.isRunning;
}

// Stubs required for FBNeo integration
extern "C" {
    // Initialize the audio subsystem
    int AudSoundInit() {
        return MetalAudio_Init(48000, 2);
    }
    
    // Clean up audio resources
    int AudSoundExit() {
        return MetalAudio_Exit();
    }
    
    // Reset the audio system
    int AudSoundReset() {
        return MetalAudio_Reset();
    }
    
    // Set the volume
    void AudSoundSetVolume(int nVolume) {
        // Convert from FBNeo volume (0-100) to float (0.0-1.0)
        float volume = (float)nVolume / 100.0f;
        MetalAudio_SetVolume(volume);
    }
}

// Initialize audio system
int Metal_InitAudioSystem(int sampleRate) {
    if (audioInitialized) {
        return 0;
    }
    
    audioSampleRate = sampleRate;
    audioSemaphore = dispatch_semaphore_create(1);
    
    // Allocate buffer (2 seconds of audio)
    audioBufferSize = audioSampleRate * audioChannels * 2;
    audioBuffer = (short*)calloc(audioBufferSize, sizeof(short));
    if (!audioBuffer) {
        NSLog(@"Failed to allocate audio buffer");
        return 1;
    }
    
    @autoreleasepool {
        // Create audio engine
        audioEngine = [[AVAudioEngine alloc] init];
        
        // Configure audio format
        AVAudioFormat* format = [[AVAudioFormat alloc] 
                                initStandardFormatWithSampleRate:audioSampleRate 
                                channels:audioChannels];
        
        // Create source node with callback
        sourceNode = [[AVAudioSourceNode alloc] 
                     initWithFormat:format 
                     renderBlock:^OSStatus(BOOL *isSilence, 
                                          const AudioTimeStamp *timestamp, 
                                          AVAudioFrameCount frameCount, 
                                          AudioBufferList *outputData) {
            
            // Lock buffer access
            dispatch_semaphore_wait(audioSemaphore, DISPATCH_TIME_FOREVER);
            
            // Check if we have data
            if (!audioBuffer || audioBufferPos >= audioBufferSize) {
                *isSilence = YES;
                dispatch_semaphore_signal(audioSemaphore);
                return noErr;
            }
            
            // Get pointer to output buffer
            float* outputBuffer = (float*)outputData->mBuffers[0].mData;
            int outputChannels = outputData->mBuffers[0].mNumberChannels;
            
            // Copy data to output buffer
            for (int i = 0; i < frameCount; i++) {
                if (audioBufferPos >= audioBufferSize) {
                    // Fill rest with silence
                    for (int j = i; j < frameCount; j++) {
                        for (int ch = 0; ch < outputChannels; ch++) {
                            outputBuffer[j * outputChannels + ch] = 0.0f;
                        }
                    }
                    break;
                }
                
                // Left channel
                outputBuffer[i * outputChannels] = audioBuffer[audioBufferPos] / 32768.0f;
                audioBufferPos++;
                
                // Right channel (if stereo)
                if (outputChannels > 1 && audioBufferPos < audioBufferSize) {
                    outputBuffer[i * outputChannels + 1] = audioBuffer[audioBufferPos] / 32768.0f;
                    audioBufferPos++;
                }
            }
            
            *isSilence = NO;
            dispatch_semaphore_signal(audioSemaphore);
            return noErr;
        }];
        
        // Connect nodes
        [audioEngine attachNode:sourceNode];
        [audioEngine connect:sourceNode to:audioEngine.mainMixerNode format:format];
        
        // Prepare and start
        NSError* error = nil;
        if (![audioEngine startAndReturnError:&error]) {
            NSLog(@"Failed to start audio engine: %@", error);
            return 1;
        }
        
        audioInitialized = YES;
        NSLog(@"Audio system initialized at %d Hz", audioSampleRate);
    }
    
    return 0;
}

// Add audio samples to buffer
int Metal_AddAudioSamples(const short* samples, int count) {
    if (!audioInitialized || !audioBuffer || !samples || count <= 0) {
        return 1;
    }
    
    // Lock buffer access
    dispatch_semaphore_wait(audioSemaphore, DISPATCH_TIME_FOREVER);
    
    // Reset buffer position if it's near the end
    if (audioBufferPos >= audioBufferSize - count) {
        audioBufferPos = 0;
    }
    
    // Copy samples to buffer
    memcpy(audioBuffer + audioBufferPos, samples, count * sizeof(short));
    audioBufferPos += count;
    
    dispatch_semaphore_signal(audioSemaphore);
    return 0;
}

// Stop audio system
void Metal_StopAudioSystem() {
    if (audioInitialized) {
        [audioEngine stop];
        audioEngine = nil;
        sourceNode = nil;
        
        if (audioBuffer) {
            free(audioBuffer);
            audioBuffer = NULL;
        }
        
        audioInitialized = NO;
    }
} 