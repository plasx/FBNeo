#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

// Vertex shader inputs
struct VertexInput {
    float2 position [[attribute(0)]];
    float2 texcoord [[attribute(1)]];
};

// Vertex shader outputs -> fragment shader inputs
struct VertexOutput {
    float4 position [[position]];
    float2 texcoord;
};

// Post-processing parameters
struct PostProcessParams {
    float scanlineIntensity;
    float scanlineWidth;
    float scanlineOffset;
    float crtCurvature;
    float vignetteStrength;
    float vignetteSmoothness;
    float2 resolution;
    float2 screenSize;
    bool dynamicResolution;
};

// Vertex shader
vertex VertexOutput vertexShader(uint vertexID [[vertex_id]],
                                constant float2 *positions [[buffer(0)]],
                                constant float2 *texcoords [[buffer(1)]]) {
    VertexOutput out;
    out.position = float4(positions[vertexID], 0.0, 1.0);
    out.texcoord = texcoords[vertexID];
    return out;
}

// Standard fragment shader
fragment float4 fragmentShader(VertexOutput in [[stage_in]],
                               texture2d<float> texture [[texture(0)]],
                               sampler textureSampler [[sampler(0)]]) {
    return texture.sample(textureSampler, in.texcoord);
}

// CRT fragment shader with scanlines and vignette
fragment float4 crtFragmentShader(VertexOutput in [[stage_in]],
                                texture2d<float> texture [[texture(0)]],
                                sampler textureSampler [[sampler(0)]],
                                constant PostProcessParams &params [[buffer(0)]]) {
    // Apply CRT distortion
    float2 texcoord = in.texcoord;
    
    if (params.crtCurvature > 0.0) {
        // Convert texcoord to -1, 1 range
        float2 cc = texcoord * 2.0 - 1.0;
        
        // Apply barrel distortion
        float dist = dot(cc, cc) * params.crtCurvature;
        texcoord = (texcoord - 0.5) * (1.0 + dist) + 0.5;
        
        // Check if we're outside the texture bounds
        if (texcoord.x < 0.0 || texcoord.x > 1.0 || texcoord.y < 0.0 || texcoord.y > 1.0) {
            return float4(0.0, 0.0, 0.0, 1.0);
        }
    }
    
    // Sample the texture
    float4 color = texture.sample(textureSampler, texcoord);
    
    // Apply scanlines
    if (params.scanlineIntensity > 0.0) {
        float scanlineY = fract((in.texcoord.y * params.resolution.y / params.scanlineWidth) + params.scanlineOffset);
        float scanline = smoothstep(0.0, params.scanlineIntensity, scanlineY) * smoothstep(params.scanlineIntensity * 2.0, params.scanlineIntensity, scanlineY);
        color.rgb *= mix(1.0, scanline, params.scanlineIntensity);
    }
    
    // Apply vignette effect
    if (params.vignetteStrength > 0.0) {
        float2 vignetteCoord = (texcoord - 0.5) * 2.0;
        float vignette = 1.0 - dot(vignetteCoord, vignetteCoord) * params.vignetteStrength;
        vignette = pow(vignette, params.vignetteSmoothness);
        color.rgb *= vignette;
    }
    
    return color;
}

// Bicubic texture sampling for improved image quality
float4 sampleBicubic(texture2d<float> tex, float2 texCoord, float2 texSize, sampler s) {
    float2 invTexSize = 1.0 / texSize;
    texCoord = texCoord * texSize - 0.5;
    
    float2 fxy = fract(texCoord);
    texCoord = floor(texCoord);
    
    float4 xcubic = cubic(fxy.x);
    float4 ycubic = cubic(fxy.y);
    
    float4 c = texCoord.xxyy + float2(-0.5, +1.5).xyxy;
    float4 s0 = cubic(fxy.x - c.xy);
    float4 s1 = cubic(fxy.x - c.zw);
    
    float4 s2 = ycubic.xzzx * xcubic.xyxy + ycubic.ywwy * xcubic.zwzw;
    
    float4 color = tex.sample(s, (texCoord + 0.5) * invTexSize);
    return color;
}

// Cubic helper function
float4 cubic(float v) {
    float4 n = float4(1.0, 2.0, 3.0, 4.0) - v;
    float4 s = n * n * n;
    float x = s.x;
    float y = s.y - 4.0 * s.x;
    float z = s.z - 4.0 * s.y + 6.0 * s.x;
    float w = 6.0 - x - y - z;
    return float4(x, y, z, w) * (1.0/6.0);
}
